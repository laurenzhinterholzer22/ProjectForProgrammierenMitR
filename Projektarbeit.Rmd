---
title: "Projektarbeit"
author: "Laurenz Hinterholzer & Manuel Karlsberger"
date: "7/22/2020"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Aufgabe 1

Einlesen der Daten

```{r}
yearLsoa <- read.csv(file = "year_lsoa_grocery.csv", header = TRUE, sep =",")
lsoaArea <- yearLsoa$area_sq_km
lsoaPopulation <- yearLsoa$population

yearMsoa <- read.csv(file = "year_msoa_grocery.csv", header = TRUE, sep =",")
msoaArea <- yearMsoa$area_sq_km
msoaPopulation <- yearMsoa$population

yearOsward <- read.csv(file = "year_osward_grocery.csv", header = TRUE, sep =",")
oswardArea <- yearOsward$area_sq_km
oswardPopulation <- yearOsward$population

yearBorough <- read.csv(file = "year_borough_grocery.csv", header = TRUE, sep = ",")
boroughArea <- yearBorough$area_sq_km
boroughPopulation <- yearBorough$population

```
 Bestimmung der Gesamtbevoelkerung, Gesamtflaeche und relativen porzentuellen Abweichungen.
 
 
```{r results="hide"}
areas <- list(lsoa = lsoaArea, msoa =  msoaArea,  ward = oswardArea, borough = boroughArea)
population <- list(lsoa = lsoaPopulation, msoa = msoaPopulation, ward = oswardPopulation, borough = boroughPopulation)

lapply(areas, sum)     
lapply(population, sum)    


relDif <- function(var){
  x <- numeric()
  for (i in seq_along(var)){
    x <- append(x, round((max(var)-var[i])/max(var)*100,2))
  }
  return(x)
}

lapply(areas, relDif)
lapply(population, relDif)
```
Nachdem die vier Aggregationsgrade eingelesen und nach der Flaeche und Bevoelkerung jeweils getrennt und gelistet wurden, haben wir mit lapply jeweils die Gesamtflaeche und Gesamtbevoelkerung bestimmt.
Dabei wurde festgestellt, dass bis auf den Aggregationsgrad LSOA, alle Grade 1572.48km2 Flaeche und  8666930 Einwohner haben.
LSOA hat um 0,7 km2 weniger Flaeche und um 2822 weniger Einwohner als die Anderen.

Bei der Berechnung der jeweiligen relativen prozentuellen Abweichungen vom jeweiligen Maximum kann man aufgrund einiger Ausreißern bei allen Aggregationsgraden eine großteils hohe Abweichung vom Maximum feststellen.




Dataframe 

```{r}
noAreas <- lapply(areas, length) 

tab1Dataframe <- data.frame(
  Area = c("LSOA","MSOA","Ward","Borough"),
  NumberOfAreas = unlist(noAreas),
  AvgSurfaces = round(unlist(Map("/", lapply(areas, sum), noAreas)),2),
  AvgPopulation = round(unlist(Map("/", lapply(population, sum), noAreas)),0),
  MedianPopulation = unlist(lapply(population, median)),
  MedianArea = unlist(lapply(areas, median)),
  stringsAsFactors = FALSE
)
rownames(tab1Dataframe) <- NULL
tab1Dataframe
```
Der Dataframe der Tabelle 1 in Aiello et al. (2020) ist annaehernd der selbe wie den wir reproduziert haben. Ein kleiner Unterschied kann man bei der durchschnittlichen Flaeche bei dem Aggregationsgrad Borough festellen, wobei dieser Unterschied auch ein Rundungsfehler sein koennte.

Visualisierung

```{r}
par(mfrow=c(1,2))
hist(lsoaPopulation, main = "Lsoa Bevoelkerung", xlab = "Bevoelkerung", ylab = "Haeufigkeit",breaks= seq(min(lsoaPopulation),max(lsoaPopulation)+100, 200), col =3, freq = FALSE, xlim = c(0,4000))
hist(lsoaArea, main = "Lsoa Flaeche",xlab = "Flaeche", ylab = "Haeufigkeit", breaks= seq(min(lsoaArea),max(lsoaArea)+0.5, 0.5), col =4, freq = FALSE, xlim = c(0,4))

```
Schlussendlich wurden die Daten des kleinsten Aggregationsgrades, also Lsoa, visualisiert. Um die Bevoelkerung und Flaeche zu visulisieren, haben wir ein Histogramm verwendet und die Daten bei der Bevoelkerung auf 0-4000 und bei der Flaeche auf 0-4 beschraenkt, um die Ausreisser zu eliminieren und 
die aussagekraeftigen Daten besser zu veranschaulichen. Die bevoelkerung hat die meisten Auspraegungen bei ca 1800 und die Flaeche zwischen 0 und 1.

Aufgabe 2

Einlesen der Daten

```{r results="hide"}
library(sf)
boundariesLondon <- st_read("./statistical-gis-boundaries-london/statistical-gis-boundaries-london/ESRI/LSOA_2011_London_gen_MHW.shp")
```

Bestimmung von Klasse, Dimensionen und Spaltennamen

```{r}
class(boundariesLondon)
dim(boundariesLondon)
colnames(boundariesLondon)
```

Verknuepfung der Daten mit Lsoa

```{r}
mergeboundaries <- merge(boundariesLondon, yearLsoa, by.x = "LSOA11CD", by.y = "area_id")
class(mergeboundaries)
dim(mergeboundaries)    
colnames(mergeboundaries)
```
Visualisierung

```{r}
library("colorspace")

par(mfrow=c(1,2))

plot(mergeboundaries["num_transactions"], logz = TRUE, main = "Number of Transactions", pal = terrain_hcl)

mergeboundaries$perresident <- mergeboundaries$num_transactions/mergeboundaries$population
plot(mergeboundaries["perresident"], logz = TRUE, main = "Transactions per resident", pal = terrain_hcl) 
```
Bei der Reproduktion der Grafik Abbildung 3 in Aiello et al. (2020) erkennt man bis auf die Farbpalette keine Unterschiede. Weiters ist die Grafik welche die Anzahl der Transaktionen visualisiert, bis auf die Skalierung annaehernd ident.

Aufgabe 3

Visualisierung

```{r}
sequ <- seq(0, 1, by = 0.01)

dat <- list(lsoa = yearLsoa, msoa = yearMsoa, ward = yearOsward)

repr <- function(var){
  x <- numeric()
  for(i in sequ){
    x <- append(x, nrow(var[var$representativeness_norm > i,])/nrow(var))
  }
  return(list(seq = sequ, perc = x))
}

normRepr <- lapply(dat, repr)

par(mfrow=c(1,1))
plot(as.data.frame(normRepr$lsoa), main = "Representativitaet", xlab = "Threshold")
lines(as.data.frame(normRepr$msoa), lty = 1)
lines(as.data.frame(normRepr$ward), lty = 2)
legend("topright", c("lsoa", "msoa", "ward"), lty = c(NA,1,2), pch = c(1,NA,NA))
```
Bei dieser Grafik wird mithilfe der Daten von Lsoa,Msoa und Ward die Abbildung 4 links in Aiello et al. (2020) visualisiert.Wobei man bei dieser Grafik schon einen deutlichen Unterschied zu der Grafik in Aiello sieht. Bei Aiello sind die drei Aggregationsgrade annaehernd ident und naehern sich bereits bei 0.4 Threhold der X-Achse. Bei unserer Grafik verhaelt  sich nur Lsoa wie bei Aello und Msoa und Ward flachen erst ab 0.5 ab und schneiden erst bei 0.8 der X-Achse.